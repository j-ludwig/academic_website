[["index.html", "Module 1: Introduction to RStudio Overview", " Module 1: Introduction to RStudio Julian F. Ludwig 2023-07-01 Overview This module provides an overview of the software used in this course, guides you through the installation process, and helps you become familiar with their usage. All the software used in this course is freely available. "],["software-overview.html", "Chapter 1 Software Overview", " Chapter 1 Software Overview This course makes use of various software tools and programming languages that are essential for conducting economic analyses. The following software and programming languages will be used: R: R is a programming language designed for statistical computing and graphics. This language is widely used by data scientists and researchers for a range of tasks such as data processing, visualization, model estimation, and performing predictive or causal inference. For instance, one can use R to import GDP data, plot the data, compute the GDP growth rate from this data, and finally, apply time-series modeling techniques to predict future GDP growth. LaTeX: LaTeX is a powerful document preparation system widely used for typesetting scientific and technical documents. Similar to Microsoft Word, LaTeX is a text formatting software, but it offers advanced support for mathematical equations, cross-references, bibliographies, and more. LaTeX is particularly useful for creating professional-looking PDF documents with complex mathematical notation. Markdown: Markdown is designed for simple and easy formatting of plain text documents. It uses plain text characters and a simple syntax to add formatting elements such as headings, lists, emphasis, links, images, and code blocks. Markdown allows for quick and readable content creation without the need for complex formatting options. It is often used for creating documentation, writing blog posts, and formatting text in online forums. Markdown documents can be easily converted to other formats, making it highly portable. R Markdown: R Markdown combines R with Markdown, LaTeX, and Microsoft Word. This fusion creates an environment where data scientists and researchers can combine text and R code within the same document, eliminating the process of creating graphs in R and then transferring them to a Word or LaTeX document. An R Markdown document can be converted into several formats, including HTML, PDF, or Word. To generate a PDF, R Markdown initially crafts a LaTeX file which it then executes in the background. Thanks to the embedded R code in the R Markdown document, it’s possible to automate data downloading and updating to ensure a financial report remains up-to-date. In fact, the text you’re reading now was crafted with R Markdown. RStudio: RStudio is an Integrated Development Environment (IDE) for R. An IDE is a software application that combines multiple programs into a single, user-friendly platform. Think of RStudio as the all-in-one tool you’ll use in this course - it will handle all tasks, running R, Markdown, and LaTeX in the background for you. However, for RStudio to work, R, R Markdown, and a LaTeX processor must be installed on your computer, so that RStudio can use these programs in the background. R packages: R provides a rich set of basic functions that can be extended with R packages. These packages are a collection of functions written by contributors for specific tasks. For example, the quantmod package provides functions for financial quantitative modeling. These are all open-source programs, meaning they are freely available to users and their development is driven by a community of developers who voluntarily contribute their expertise to improve their functionalities. By gaining proficiency in these software tools and programming languages, you will have a solid foundation for performing data analysis, creating reproducible reports, and effectively communicating your findings in a professional manner. "],["software-installation.html", "Chapter 2 Software Installation 2.1 Install R 2.2 Install RStudio 2.3 Install R Markdown 2.4 Install LaTeX 2.5 Install R Packages 2.6 18-Step Test", " Chapter 2 Software Installation For this course, you will only use RStudio for writing code and text. However, as RStudio is an IDE rather than a standalone program, it relies on the presence of R, R Markdown, and a LaTeX processor on your computer. RStudio interacts with these programs in the background to generate an output. Below, you will find the installation instructions for each of these programs. Additionally, a set of 18 steps is provided to help you verify whether R, RStudio, R Markdown, and LaTeX have been installed correctly. 2.1 Install R To install R on your computer, follow the instructions below: For MacOS: To download R for MacOS, visit the R project website: www.r-project.org. Click CRAN mirror and choose your preferred mirror. It doesn’t really matter which mirror you choose, simply choose a location close to you, e.g. National Institute for Computational Sciences, Oak Ridge, TN. Select Download R for macOS. Under “Latest release”, read the first paragraph to check whether the program is compatible with your operating system (OS) and processor. To find your computer’s OS and processor, click the top left Apple icon, and click “About this Mac.” Under “macOS”, you will see both the name (e.g. “Ventura”, “Catalina”, “Monterey”) and the number (e.g. “Version 13.4.1”) of the OS, and under “Processor” you will either see that your computer is run by an Intel processor or an Apple silicon (M1/M2) processor. If the operating system (OS) and the processor are compatible, click on the first R-X.X.X.pkg (where X represents the R version numbers). Otherwise, if you have an older OS or an Intel processor, click on a version further down that is compatible with your system. Once the file has downloaded, click it to proceed to installation, leaving all default settings as they are. For Windows: To download R for Windows, visit the R project website: www.r-project.org. Click CRAN mirror and choose your preferred mirror. It doesn’t really matter which mirror you choose, simply choose a location close to you, e.g. Revolution Analytics, Dallas, TX. Select Download R for Windows. Select “base”, and read whether the program is compatible with your Windows version. If it is compatible, click Download R-X.X.X for Windows (X are numbers), and otherwise click here for older versions. Once the file has downloaded, click it to proceed to installation, leaving all default settings as they are. 2.2 Install RStudio Visit the RStudio website: www.rstudio.com and navigate to the download page. Click DOWNLOAD. Scroll down to “All Installers” section. Choose the download that matches your computer. If you have a Mac, it’s most likely “macOS 10.15+”; then click the download link (e.g. “RStudio-2022.07.1-554.dmg”). If you have a Windows, it’s most likely “Windows 10/11” and click the download link (e.g. “RStudio-2022.07.1-554.exe”). Open the file when it has downloaded, and install with the default settings. 2.3 Install R Markdown R Markdown can be installed from inside the RStudio IDE. To download R Markdown, open RStudio, after you have successfully installed R and RStudio. In RStudio, find the “Console” window. Type the command install.packages(\"rmarkdown\") in the console and press Enter. 2.4 Install LaTeX When it comes to installing LaTeX, there are several software options available. While most options work well, I recommend using TinyTeX. TinyTeX as it is an easy-to-maintain LaTeX distribution. Other good alternatives include MacTeX and MiKTeX. LaTeX is the underlying program responsible for word processing and generating PDF reports within RStudio. To install TinyTeX using RStudio, follow these steps: Open RStudio after successfully installing R, RStudio, and R Markdown. Locate the “Console” window within RStudio. Type install.packages(\"tinytex\") and press Enter. Type tinytex::install_tinytex() and press Enter. Type install.packages(\"knitr\") and press Enter. 2.5 Install R Packages R provides a set of basic functions that can be extended using packages. To install a package (e.g., quantmod), follow these steps: Open RStudio. In the RStudio window, find the “Console” window. Type the command install.packages(\"quantmod\") in the console and press Enter. Wait for the installation process to complete. R will download and install the package from the appropriate repository. After installation, you can use the package in your script by including the line library(\"quantmod\") at the beginning. Remember to execute the library(\"quantmod\") command each time you want to use functions from the quantmod package in your code. It is common practice to load the necessary packages at the beginning of your script, even if you don’t use all of them immediately. This ensures that all the required functions and tools are available when needed and promotes a consistent and organized approach to package management in your code. As a side note, the quantmod package includes the getSymbols function, which is commonly used to download financial data, such as the S&amp;P 500 index (GSPC): library(&quot;quantmod&quot;) ## Loading required package: xts ## Loading required package: zoo ## ## Attaching package: &#39;zoo&#39; ## The following objects are masked from &#39;package:base&#39;: ## ## as.Date, as.Date.numeric ## Loading required package: TTR ## Registered S3 method overwritten by &#39;quantmod&#39;: ## method from ## as.zoo.data.frame zoo getSymbols(Symbols=&quot;^GSPC&quot;) ## [1] &quot;GSPC&quot; head(GSPC) ## GSPC.Open GSPC.High GSPC.Low GSPC.Close GSPC.Volume GSPC.Adjusted ## 2007-01-03 1418.03 1429.42 1407.86 1416.60 3429160000 1416.60 ## 2007-01-04 1416.60 1421.84 1408.43 1418.34 3004460000 1418.34 ## 2007-01-05 1418.34 1418.34 1405.75 1409.71 2919400000 1409.71 ## 2007-01-08 1409.26 1414.98 1403.97 1412.84 2763340000 1412.84 ## 2007-01-09 1412.84 1415.61 1405.42 1412.11 3038380000 1412.11 ## 2007-01-10 1408.70 1415.99 1405.32 1414.85 2764660000 1414.85 Here, the getSymbols function retrieves the historical data for the S&amp;P 500 index from Yahoo Finance, and stores it in the GSPC object. The head function then displays the first few rows of the downloaded data. R packages provide a wealth of specialized functions for specific tasks. To use a function from a particular package, you can indicate the package by preceding the function with the package name followed by a double colon ::. For example, quantmod::getSymbols() specifies the getSymbols() function from the quantmod package. This practice helps to avoid conflicts when multiple packages provide functions with the same name. It also allows users to easily identify the package associated with the function, promoting clarity and reproducibility in code. 2.6 18-Step Test To ensure that R, RStudio, R Markdown, and LaTeX are installed properly, you can follow the 18-step test provided in the module. This test will help verify the functionality of the installed programs and identify any potential issues or errors. During this process, you may encounter the following issues: Issue with Generating PDF: If you are unable to generate a PDF file in step 15, it is likely due to an issue with the installation of LaTeX. In such cases, please revisit the instructions for installing LaTeX in Section 2.4 and ensure you have followed them correctly. Alternatively, you can consider installing MacTeX or MiKTeX instead of TinyTeX. Non-Latin Alphabet Language: If your computer language is not based on the Latin alphabet (e.g., Chinese, Arabic, Farsi, Russian, etc.), additional instructions may be required. You can refer to this video for specific guidance: youtu.be/pX_fy2fyM30. I encourage you to persist and do your best to install all the required software, even if it takes some time. Downloading and installing programs is a critical skill that is essential in almost every profession today. This is an excellent opportunity to acquire this skill. Keep going and don’t hesitate to seek additional support or resources if needed. It’s common to encounter challenges when installing software, and resources like google.com and stackoverflow.com can provide helpful answers and suggestions. If you encounter an error, simply copy and paste the error message into a search engine, and you’ll likely find solutions and guidance from the community. If you fail to install R, RStudio, and LaTeX, I recommend using RStudio Cloud, an online platform where you can perform all the necessary tasks directly in your web browser. You can access RStudio Cloud at rstudio.cloud. While signing up is free, please note that some features may require a fee. Make a Plot To continue with the test, make sure you have R, RStudio, R Markdown, and LaTeX installed and are connected to the internet. Follow the steps below in RStudio: Type and execute install.packages(\"quantmod\") in the RStudio console. Click on the top-left plus sign then click R Script. Click File - Save As... then choose a familiar folder. Copy and paste the following R code into your R Script: library(&quot;quantmod&quot;) treasury10y &lt;- getSymbols(Symbols = &quot;GS10&quot;, src = &quot;FRED&quot;, auto.assign = FALSE) plot(treasury10y, main = &quot;10-Year Treasury Rate&quot;) Figure 2.1: R Plot Click on Source: (or use the shortcut Ctrl+Shift+Enter or Cmd+Shift+Return). You should now see a plot of the 10-year Treasury rate on your screen. Compare it to the rate displayed on fred.stlouisfed.org/series/GS10. Save Plot as PDF Continue with the following steps in RStudio: Add the line: pdf(file=\"myplot.pdf\",width=6,height=4) before the plot function, and add dev.off() after the plot: library(&quot;quantmod&quot;) treasury10y &lt;- getSymbols(Symbols = &quot;GS10&quot;, src = &quot;FRED&quot;, auto.assign = FALSE) pdf(file = &quot;myplot.pdf&quot;, width = 6, height = 4) plot(treasury10y, main = &quot;10-Year Treasury Rate&quot;) dev.off() Click on Source: (or use the shortcut Ctrl+Shift+Enter or Cmd+Shift+Return). Now navigate to the same folder on your computer where you saved the R script. There should be a file called myplot.pdf - open it. You should now see the PDF version of the plot displaying the Treasury rate. If you encounter no error message but cannot locate the myplot.pdf file, it’s possible that R saved it in a different folder than where the R script is located. To check where R saves the plot, type getwd() in the console, which stands for “get working directory.” If you want to change the working directory and have R save the files in a different folder, type setwd(\"/Users/.../...\"), replacing \"/Users/.../...\" with the path to the desired folder. Run Marked Code To run only one line or one variable, mark it and then click Run: (or use the shortcut Ctrl+Enter or Cmd+Return). Follow these steps in RStudio: Mark the variable treasury10y: Click Run: (or use shortcut Ctrl+Enter or Cmd+Return) You should see the data displayed in your console, ending with 2023-05-01 3.57. Create PDF with R Markdown Next, let’s ensure that R Markdown is working. If you have installed LaTeX and knitr, follow these steps in RStudio: Click on the top-left plus sign then click R Markdown... A dialog box will appear - select Document and choose PDF, then click OK: Figure 2.2: New R Markdown You should now see a file with text and code. Click File - Save As... and choose a familiar folder to save the file. Click Knit: (or use the shortcut Ctrl+Shift+K or Cmd+Shift+K). A PDF file should appear on your screen and also in your chosen folder. Next, locate the following lines: 16 ```{r cars} 17 summary(cars) 18 ``` Replace these lines with the following (do not copy the line numbers): 16 ```{r, message=FALSE,warning=FALSE,echo=FALSE} 17 library(&quot;quantmod&quot;) 18 treasury10y &lt;- getSymbols(Symbols=&quot;GS10&quot;,src=&quot;FRED&quot;,auto.assign=FALSE) 19 plot(treasury10y,main=&quot;10-Year Treasury Rate&quot;) 20 ``` Click Knit: (or use the shortcut Ctrl+Shift+K or Cmd+Shift+K). You should now see a file that looks similar to this: Figure 2.3: PDF File Produced with R Markdown Hint: You can set echo=TRUE to include R code in your report. You can now change the title of the file and the text to create a professional report. If you click the arrow next to Knit: you have options to export your file as an HTML or Word document instead of a PDF document, which is convenient when designing a website or writing an app: Troubleshooting That’s it! If everything worked as expected, you’re good to go. If not, continue troubleshooting until it works. "],["getting-started.html", "Chapter 3 Getting Started 3.1 RStudio Interface 3.2 R Data Types and Structures 3.3 Importing Data in R", " Chapter 3 Getting Started R is a programming language and free software environment for statistical computing and graphics supported by the R Foundation for Statistical Computing. 3.1 RStudio Interface After launching RStudio on your computer, navigate to the menu bar and select “File,” then choose “New File,” and finally click on “R Script.” Alternatively, you can use the keyboard shortcut Ctrl+Shift+N (Windows/Linux) or Cmd+Shift+N (Mac) to create a new R script directly. Figure 3.1: RStudio Interface Once you have opened a new R script, you will notice that RStudio consists of four main sections: Source (top-left): This section is where you write your R scripts. Also known as do-files, R scripts are files that contain a sequence of commands which can be executed either wholly or partially. To run a single line in your script, click on that line with your cursor and press the button. However, to streamline your workflow, I recommend using the keyboard shortcut Ctrl+Enter (Windows/Linux) or Cmd+Enter (Mac) to run the line without reaching for the mouse. If you want to execute only a specific portion of a line, select that part and then press Ctrl+Enter or Cmd+Enter. To run all the commands in your R script, use the button or the keyboard shortcut Ctrl+Shift+Enter (Windows/Linux) or Cmd+Shift+Enter (Mac). Console (bottom-left): Located below the Source section, the Console is where R executes your commands. You can also directly type commands into the Console and see their output immediately. However, it is advisable to write commands in the R Script instead of the Console. By doing so, you can save the commands for future reference, enabling you to reproduce your results at a later time. Environment (top-right): In the upper-right section, the Environment tab displays the current objects stored in memory, providing an overview of your variables, functions, and data frames. To create a variable, you can use the assignment operator &lt;- (reversed arrow). Once a variable is created and assigned a numeric value, it can be utilized in arithmetic operations. For example: a &lt;- 60 a + 20 ## [1] 80 Files/Plots/Packages/Help/Viewer (bottom-right): The bottom-right panel contains multiple tabs: Files: displays your files and folders Plots: displays your graphs Packages: lets you manage your R packages Help: provides help documentation Viewer: lets you view local web content These four main sections of RStudio provide a comprehensive environment for writing, executing, and managing your R code efficiently. R Scripts An R script is a text file that contains your R code. You can execute parts of the script by selecting a subset of commands and pressing Ctrl+Enter or Cmd+Enter, or run the entire script by pressing Ctrl+Shift+Enter. Any text written after a hashtag (#) in an R Script is considered comments and is not executed as code. Comments are valuable for providing explanations or annotations for your commands, enhancing the readability and comprehensibility of your code. # This is a comment in an R script x &lt;- 10 # Assign the value 10 to x y &lt;- 20 # Assign the value 20 to y z &lt;- x + y # Add x and y and assign the result to z print(z) # Print the value of z ## [1] 30 The output displayed after two hashtags (##) in the example above: ## [1] 30, is not part of the actual R Script. Instead, it represents a line you would observe in your console when running the R Script. It showcases the result or value of the variable z in this case. To facilitate working with lengthy R scripts, it is recommended to use a separate window. You can open a separate window by selecting in the top-left corner. Figure 3.2: RStudio Interface with Separate R Script Window When the R Script is in a separate window, you can easily switch between the R Script window and the Console/Environment/Plot Window by pressing Ctrl+Tab or Cmd+Tab. This allows for convenient navigation between different RStudio windows. 3.2 R Data Types and Structures The R language supports a broad array of operations such as mathematical calculations, logical analyses, and text manipulation. However, the applicability of a function to a variable depends on the variable’s data type. For instance, an arithmetic function to add two variables won’t work if the variables store text. R supports various data types, including numeric (x &lt;- 15), character (x &lt;- \"Hello!\"), and logical (x &lt;- TRUE or x &lt;- FALSE). In addition to single values (scalars), R allows variables to hold collections of numbers or strings using vectors, matrices, lists, or data frames. Advanced data structures such as tibbles, data tables, and xts objects provide additional features beyond traditional data frames. In this section, we will explore the following data types: Scalar: A single data element, such as a number or a character string. Vector: A one-dimensional array that contains elements of the same type. Matrix (matrix): A two-dimensional array with elements of the same type. List (list): A one-dimensional array capable of storing various data types. Data Frame (data.frame): A two-dimensional array that can accommodate columns of different types. Tibble (tibble): An enhanced version of data frames, offering user-friendly features. Data Table (data.table): An optimized data frame extension designed for speed and handling large datasets. Extensible Time Series (xts): A time-indexed data frame specifically designed for time series data. Understanding the data type of variables is crucial because it determines the operations and functions that can be applied to them. It’s worth noting that R provides so-called wrapper functions, which are functions that have the same name but perform different actions depending on the data object. These wrapper functions adapt their behavior based on the input data type, allowing for more flexible and intuitive programming. For example, the summary() function in R is a wrapper function. When applied to a numeric vector, it provides statistical summaries such as mean, median, and quartiles. However, when applied to a data frame, it gives a summary of each variable, including the minimum, maximum, and quartiles for numerical variables, as well as counts and levels for categorical variables. 3.2.1 Scalar Scalars in R are variables holding single objects. You can determine an object’s type by applying the class() function to the variable. Numbers, Characters, and Logical Values # Numeric (a.k.a. Double) w &lt;- 5.5 # w is a decimal number. class(w) # Returns &quot;numeric&quot;. # Integer x &lt;- 10L # The L tells R to store x as an integer instead of a decimal number. class(x) # Returns &quot;integer&quot;. # Complex u &lt;- 3 + 4i # u is a complex number, where 3 is real and 4 is imaginary. class(u) # Returns &quot;complex&quot;. # Character y &lt;- &quot;Hello, World!&quot; # y is a character string. class(y) # Returns &quot;character&quot;. # Logical z &lt;- TRUE # z is a logical value. class(z) # Returns &quot;logical&quot;. ## [1] &quot;numeric&quot; ## [1] &quot;integer&quot; ## [1] &quot;complex&quot; ## [1] &quot;character&quot; ## [1] &quot;logical&quot; An object’s type dictates which functions can be applied. For example, mathematical functions are applicable to numbers but not characters: # Mathematical operations 2 + 2 # Results in 4. 3 * 5 # Results in 15. (1 + 2) * 3 # Results in 9 (parentheses take precedence). # Logical operations TRUE &amp; FALSE # Results in FALSE (logical AND). TRUE | FALSE # Results in TRUE (logical OR). # String operations paste(&quot;Hello&quot;, &quot;World!&quot;) # Concatenates strings, results in &quot;Hello World!&quot;. nchar(&quot;Hello&quot;) # Counts characters in a string, results in 5. ## [1] 4 ## [1] 15 ## [1] 9 ## [1] FALSE ## [1] TRUE ## [1] &quot;Hello World!&quot; ## [1] 5 Dates and Times In this course, we also deal with data types specifically designed for storing date and time information: # Date v &lt;- as.Date(&quot;2023-06-30&quot;) # v is a Date. # The default input format is %Y-%m-%d, where # - %Y is year in 4 digits, # - %m is month with 2 digits, and # - %d is day with 2 digits. class(v) # Returns &quot;Date&quot;. ## [1] &quot;Date&quot; # POSIXct (Time) t &lt;- as.POSIXct(&quot;2023-06-30 18:47:10&quot;, tz = &quot;CDT&quot;) # t is a POSIXct. ## Warning in strptime(xx, f, tz = tz): unknown timezone &#39;CDT&#39; ## Warning in as.POSIXct.POSIXlt(x): unknown timezone &#39;CDT&#39; ## Warning in strptime(x, f, tz = tz): unknown timezone &#39;CDT&#39; ## Warning in as.POSIXct.POSIXlt(as.POSIXlt(x, tz, ...), tz, ...): unknown ## timezone &#39;CDT&#39; # The default input format is %Y-%m-%d %H:%M:%S, where # - %H is hour out of 24, # - %M is minute out of 60, and # - %S is second out of 60. # The tz input is the time zone, where CDT = Central Daylight Time. class(t) # Returns &quot;POSIXct&quot;. ## [1] &quot;POSIXct&quot; &quot;POSIXt&quot; The default input format, %Y-%m-%d or %Y-%m-%d %H:%M:%S, can be changed by specifying a format input. The output format can be adjusted by applying the format() function to the object: # Date with custom input format: v &lt;- as.Date(&quot;April 6 -- 23&quot;, format = &quot;%B %d -- %y&quot;) v # Returns default output format: %Y-%m-%d. ## [1] &quot;2023-04-06&quot; format(v, format = &quot;%B %d, %Y&quot;) # Returns a custom output format: &quot;%B %d, %Y&quot;. ## [1] &quot;April 06, 2023&quot; The syntax for different date formats can be found by typing ?strptime in the R console. Some of the most commonly used formats are outlined in the table below: Specification Description Example %a Abbreviated weekday Sun, Thu %A Full weekday Sunday, Thursday %b or %h Abbreviated month May, Jul %B Full month May, July %d Day of the month, 0-31 27, 07 %j Day of the year, 001-366 148, 188 %m Month, 01-12 05, 07 %U Week, 01-53, with Sunday as first day of the week 22, 27 %w Weekday, 0-6, Sunday is 0 0, 4 %W Week, 00-53, with Monday as first day of the week 21, 27 %x Date, locale-specific %y Year without century, 00-99 84, 05 %Y Year with century, on input: 00 to 68 prefixed by 20, 69 to 99 prefixed by 19 1984, 2005 %C Century 19, 20 %D Date formatted %m/%d/%y 5/27/84 %u Weekday, 1-7, Monday is 1 7, 4 %n Newline on output or arbitrary whitespace on input %t Tab on output or arbitrary whitespace on input Here are some example operations for Date objects: # Date Operations date1 &lt;- as.Date(&quot;2023-06-30&quot;) date2 &lt;- as.Date(&quot;2023-01-01&quot;) # Subtract dates to get the number of days between days_between &lt;- date1 - date2 days_between ## Time difference of 180 days # Add days to a date date_in_future &lt;- date1 + 30 date_in_future ## [1] &quot;2023-07-30&quot; 3.2.2 Vector In R, a vector is a homogeneous sequence of elements, meaning they must all be of the same basic type. As such, a vector can hold multiple numbers, but it cannot mix types, such as having both numbers and words. The function c() (for combine) can be used to create a vector: # Numeric vector numeric_vector &lt;- c(1, 2, 3, 4, 5) class(numeric_vector) # Returns &quot;numeric&quot;. # Character vector character_vector &lt;- c(&quot;Hello&quot;, &quot;World&quot;, &quot;!&quot;) class(character_vector) # Returns &quot;character&quot;. # Logical vector logical_vector &lt;- c(TRUE, FALSE, TRUE) class(logical_vector) # Returns &quot;logical&quot;. ## [1] &quot;numeric&quot; ## [1] &quot;character&quot; ## [1] &quot;logical&quot; The function c() can also be used to add elements to a vector: # Add elements to existing vector: x &lt;- c(1, 2, 3) x &lt;- c(x, 4, 5, 6) x ## [1] 1 2 3 4 5 6 The sec() function creates a sequence of numbers or dates: # Create a sequence of numbers: x &lt;- seq(from = 1, to = 1.5, by = 0.1) x ## [1] 1.0 1.1 1.2 1.3 1.4 1.5 # Create a sequence of dates: x &lt;- seq(from = as.Date(&quot;2004-05-01&quot;), to = as.Date(&quot;2004-12-01&quot;), by = &quot;month&quot;) x ## [1] &quot;2004-05-01&quot; &quot;2004-06-01&quot; &quot;2004-07-01&quot; &quot;2004-08-01&quot; &quot;2004-09-01&quot; ## [6] &quot;2004-10-01&quot; &quot;2004-11-01&quot; &quot;2004-12-01&quot; Missing data is represented as NA (not available). The function is.na() indicates the elements that are missing and anyNA() returns TRUE if the vector contains any missing values: x &lt;- c(1, 2, NA, NA, 4, 9, 12, 5, 4, NA) is.na(x) ## [1] FALSE FALSE TRUE TRUE FALSE FALSE FALSE FALSE FALSE TRUE anyNA(x) ## [1] TRUE A generalization of logical vectors are factors, which are vectors that restrict entries to be one of predefined categories: # Unordered factors, e.g. categories &quot;Male&quot; and &quot;Female&quot;: gender_vector &lt;- c(&quot;Male&quot;, &quot;Female&quot;, &quot;Male&quot;, &quot;Male&quot;, &quot;Male&quot;, &quot;Female&quot;, &quot;Male&quot;) factor_gender_vector &lt;- factor(gender_vector) factor_gender_vector ## [1] Male Female Male Male Male Female Male ## Levels: Female Male # Ordered factors, e.g. categories with ordering Low &lt; Medium &lt; High: temperature_vector &lt;- c(&quot;High&quot;, &quot;Low&quot;, &quot;Low&quot;, &quot;Low&quot;, &quot;Medium&quot;, &quot;Low&quot;, &quot;Low&quot;) factor_temperature_vector &lt;- factor(temperature_vector, order = TRUE, levels = c(&quot;Low&quot;, &quot;Medium&quot;, &quot;High&quot;)) factor_temperature_vector ## [1] High Low Low Low Medium Low Low ## Levels: Low &lt; Medium &lt; High 3.2.3 Matrix (matrix) A matrix in R (matrix) is a two-dimensional array that extends atomic vectors, containing both rows and columns. The elements within a matrix must be of the same data type. # Create a 3x3 numeric matrix, column-wise: numeric_matrix &lt;- matrix(1:9, nrow = 3, ncol = 3) numeric_matrix ## [,1] [,2] [,3] ## [1,] 1 4 7 ## [2,] 2 5 8 ## [3,] 3 6 9 class(numeric_matrix) # Returns &quot;matrix&quot;. ## [1] &quot;matrix&quot; &quot;array&quot; typeof(numeric_matrix) # Returns &quot;numeric&quot;. ## [1] &quot;integer&quot; # Create a 2x3 character matrix, row-wise: character_matrix &lt;- matrix(letters[1:6], nrow = 2, ncol = 3, byrow = TRUE) character_matrix ## [,1] [,2] [,3] ## [1,] &quot;a&quot; &quot;b&quot; &quot;c&quot; ## [2,] &quot;d&quot; &quot;e&quot; &quot;f&quot; class(character_matrix) # Returns &quot;matrix&quot;. ## [1] &quot;matrix&quot; &quot;array&quot; typeof(character_matrix) # Returns &quot;character&quot;. ## [1] &quot;character&quot; To select specific elements, rows, or columns within a matrix, square brackets are used. The cbind() and rbind() functions enable the combination of columns and rows, respectively. # Print element in the second row and first column: character_matrix[2, 1] ## [1] &quot;d&quot; # Print the second row: character_matrix[2, ] ## [1] &quot;d&quot; &quot;e&quot; &quot;f&quot; # Combine matrices: x &lt;- matrix(1:4, nrow = 2, ncol = 2) y &lt;- matrix(101:104, nrow = 2, ncol = 2) rbind(x, y) # Combines matrices x and y row-wise. ## [,1] [,2] ## [1,] 1 3 ## [2,] 2 4 ## [3,] 101 103 ## [4,] 102 104 cbind(x, y) # Combines matrices x and y column-wise. ## [,1] [,2] [,3] [,4] ## [1,] 1 3 101 103 ## [2,] 2 4 102 104 3.2.4 List (list) A list (list) in R serve as an ordered collection of objects. In contrast to vectors, elements within a list are not required to be of the same type. Moreover, some list elements may store multiple sub-elements, allowing for complex nested structures. For instance, a single element of a list might itself be a matrix or another list. # List my_list &lt;- list(1, &quot;a&quot;, TRUE, 1+4i, c(1, 2, 3), matrix(1:8, 2, 4), list(&quot;c&quot;,4)) names(my_list) &lt;- c(&quot;num_1&quot;, &quot;char_a&quot;, &quot;log_T&quot;, &quot;complex_1p4i&quot;, &quot;vec&quot;, &quot;mat&quot;, &quot;list&quot;) my_list ## $num_1 ## [1] 1 ## ## $char_a ## [1] &quot;a&quot; ## ## $log_T ## [1] TRUE ## ## $complex_1p4i ## [1] 1+4i ## ## $vec ## [1] 1 2 3 ## ## $mat ## [,1] [,2] [,3] [,4] ## [1,] 1 3 5 7 ## [2,] 2 4 6 8 ## ## $list ## $list[[1]] ## [1] &quot;c&quot; ## ## $list[[2]] ## [1] 4 class(my_list) # Returns &quot;list&quot;. ## [1] &quot;list&quot; The content of elements can be retrieved by using double square brackets: # Select second element: my_list[[2]] ## [1] &quot;a&quot; # Select element named &quot;mat&quot;: my_list[[&quot;mat&quot;]] ## [,1] [,2] [,3] [,4] ## [1,] 1 3 5 7 ## [2,] 2 4 6 8 3.2.5 Data Frame (data.frame) A data frame (data.frame) in R resembles a matrix in its two-dimensional, rectangular structure. However, unlike a matrix, a data frame allows each column to contain a different data type. Therefore, within each column (or vector), the elements must be homogeneous, but different columns can accommodate distinct types. Typically, when importing data into R, the default object type used is a data frame. # Vectors student_names &lt;- c(&quot;Anna&quot;, &quot;Ella&quot;, &quot;Sophia&quot;) student_ages &lt;- c(23, 21, 25) student_grades &lt;- c(&quot;A&quot;, &quot;B&quot;, &quot;A&quot;) student_major &lt;- c(&quot;Math&quot;, &quot;Biology&quot;, &quot;Physics&quot;) # Data frame students_df &lt;- data.frame(name = student_names, age = student_ages, grade = student_grades, major = student_major) students_df ## name age grade major ## 1 Anna 23 A Math ## 2 Ella 21 B Biology ## 3 Sophia 25 A Physics class(students_df) # Returns &quot;data.frame&quot;. ## [1] &quot;data.frame&quot; Data frames are frequently used for data storage and manipulation in R. The following illustrates some common functions used on data frames: # Access a column in the data frame students_df$name # Alternative way to access a column: students_df[[&quot;name&quot;]] # Access second row in third column: students_df[2, 3] ## [1] &quot;Anna&quot; &quot;Ella&quot; &quot;Sophia&quot; ## [1] &quot;Anna&quot; &quot;Ella&quot; &quot;Sophia&quot; ## [1] &quot;B&quot; # When selecting just one column, data frame produces a vector class(students_df[, 3]) # To avoid this, add drop = FALSE class(students_df[, 3 , drop = FALSE]) ## [1] &quot;character&quot; ## [1] &quot;data.frame&quot; # Add a column to the data frame students_df$gpa &lt;- c(3.8, 3.5, 3.9) students_df ## name age grade major gpa ## 1 Anna 23 A Math 3.8 ## 2 Ella 21 B Biology 3.5 ## 3 Sophia 25 A Physics 3.9 # Subset the data frame students_df[students_df$age &gt; 22 &amp; students_df$gpa &gt; 3.6, ] ## name age grade major gpa ## 1 Anna 23 A Math 3.8 ## 3 Sophia 25 A Physics 3.9 # Number of columns and rows ncol(students_df) nrow(students_df) # Column and row names colnames(students_df) rownames(students_df) ## [1] 5 ## [1] 3 ## [1] &quot;name&quot; &quot;age&quot; &quot;grade&quot; &quot;major&quot; &quot;gpa&quot; ## [1] &quot;1&quot; &quot;2&quot; &quot;3&quot; # Change column names colnames(students_df) &lt;- c(&quot;Name&quot;, &quot;Age&quot;, &quot;Grade&quot;, &quot;Major&quot;, &quot;GPA&quot;) students_df ## Name Age Grade Major GPA ## 1 Anna 23 A Math 3.8 ## 2 Ella 21 B Biology 3.5 ## 3 Sophia 25 A Physics 3.9 # Take a look at the data type of each column str(students_df) ## &#39;data.frame&#39;: 3 obs. of 5 variables: ## $ Name : chr &quot;Anna&quot; &quot;Ella&quot; &quot;Sophia&quot; ## $ Age : num 23 21 25 ## $ Grade: chr &quot;A&quot; &quot;B&quot; &quot;A&quot; ## $ Major: chr &quot;Math&quot; &quot;Biology&quot; &quot;Physics&quot; ## $ GPA : num 3.8 3.5 3.9 # Take a look at the data in a separate window View(students_df) These examples illustrate just a few of the operations you can perform with data frames in R. With additional libraries like dplyr, tidyr, and data.table, more complex manipulations are possible. 3.2.6 Tibble (tbl_df) A tibble (tbl_df) is a more convenient version of a data frame. It is part of the tibble package in the tidyverse collection of R packages. To use tibbles, you need to install the tibble package by executing install.packages(\"tibble\") in your console. Don’t forget to include library(\"tibble\") at the beginning of your R script. To create a tibble, you can use the tibble() function. Here’s an example: # Load R package library(&quot;tibble&quot;) # Create a new tibble tib &lt;- tibble(name = letters[1:3], id = sample(1:5, 3), age = sample(18:70, 3), sex = factor(c(&quot;M&quot;, &quot;F&quot;, &quot;F&quot;))) tib ## # A tibble: 3 × 4 ## name id age sex ## &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;fct&gt; ## 1 a 5 39 M ## 2 b 3 19 F ## 3 c 1 22 F class(tib) ## [1] &quot;tbl_df&quot; &quot;tbl&quot; &quot;data.frame&quot; One advantage of tibbles is that they make it easy to calculate and create new columns. Here’s an example: tib &lt;- tibble(tib, idvage = id/age) tib ## # A tibble: 3 × 5 ## name id age sex idvage ## &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;fct&gt; &lt;dbl&gt; ## 1 a 5 39 M 0.128 ## 2 b 3 19 F 0.158 ## 3 c 1 22 F 0.0455 Unlike regular data frames, tibbles allow non-standard column names. You can use special characters or numbers as column names. Here’s an example: tibble(`:)` = &quot;smile&quot;, ` ` = &quot;space&quot;, `2000` = &quot;number&quot;) ## # A tibble: 1 × 3 ## `:)` ` ` `2000` ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 smile space number Another way to create a tibble is with the tribble() function. It allows you to define column headings using formulas starting with ~ and separate entries with commas. Here’s an example: tribble( ~x, ~y, ~z, &quot;a&quot;, 2, 3.6, &quot;b&quot;, 1, 8.5 ) ## # A tibble: 2 × 3 ## x y z ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 a 2 3.6 ## 2 b 1 8.5 For additional functions and a helpful cheat sheet on tibble and dplyr, you can refer to this cheat sheet. Tidyverse The tibble package is part of the tidyverse environment, which is a collection of R packages with a shared design philosophy, grammar, and data structures. To install tidyverse, execute install.packages(\"tidyverse\"), which includes tibble, readr, dplyr, tidyr, ggplot2, and more. Key functions in the tidyverse include select(), filter(), mutate(), arrange(), count(), group_by(), and summarize(). An interesting operator in the tidyverse is the pipe operator %&gt;%, which allows you to chain functions together in a readable and sequential manner. With the pipe operator, you can order the functions as they are applied, making your code more expressive and easier to understand. Here’s an example: library(&quot;tidyverse&quot;) ## ── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ── ## ✔ dplyr 1.1.2 ✔ purrr 1.0.1 ## ✔ forcats 1.0.0 ✔ readr 2.1.4 ## ✔ ggplot2 3.4.2 ✔ stringr 1.5.0 ## ✔ lubridate 1.9.2 ✔ tidyr 1.3.0 ## ── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ── ## ✖ dplyr::filter() masks stats::filter() ## ✖ dplyr::first() masks xts::first() ## ✖ dplyr::lag() masks stats::lag() ## ✖ dplyr::last() masks xts::last() ## ℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors x &lt;- c(0.109, 0.359, 0.63, 0.996, 0.515, 0.142, 0.017, 0.829, 0.907) # Apply several functions to x: y &lt;- round(exp(diff(log(x))), 1) y ## [1] 3.3 1.8 1.6 0.5 0.3 0.1 48.8 1.1 # Perform the same computations using pipe operators: y &lt;- x %&gt;% log() %&gt;% diff() %&gt;% exp() %&gt;% round(1) y ## [1] 3.3 1.8 1.6 0.5 0.3 0.1 48.8 1.1 By using the %&gt;% operator, each function is applied to the previous result, simplifying the code and improving its readability. To delve deeper into the tidyverse, explore their official website: www.tidyverse.org. Another resource is the R-Bootcamp, available at r-bootcamp.netlify.app. Additionally, DataCamp provides a comprehensive skill track devoted to the tidyverse, named Tidyverse Fundamentals with R. 3.2.7 Data Table (data.table) A data table (data.table) is similar to a data frame but with more advanced features for data manipulation. In fact, data.table and tibble can be considered competitors, with each offering enhancements over the standard data frame. While data tables offer high-speed functions and are optimized for large datasets, tibbles from the tidyverse are slower but are more user-friendly. The syntax used in data.table functions may seem esoteric, differing from that used in tidyverse. Like tibble, data.table is not a part of base R. It requires the installation of the data.table package via install.packages(\"data.table\"), followed by library(\"data.table\") at the beginning of your script. To create a data table, you can use the data.table() function. Here’s an example: # Load R package library(&quot;data.table&quot;) ## ## Attaching package: &#39;data.table&#39; ## The following objects are masked from &#39;package:lubridate&#39;: ## ## hour, isoweek, mday, minute, month, quarter, second, wday, week, ## yday, year ## The following objects are masked from &#39;package:dplyr&#39;: ## ## between, first, last ## The following object is masked from &#39;package:purrr&#39;: ## ## transpose ## The following objects are masked from &#39;package:xts&#39;: ## ## first, last # Create a new data.table: dt &lt;- data.table(name = letters[1:3], id = sample(1:5,3), age = sample(18:70,3), sex = factor(c(&quot;M&quot;, &quot;F&quot;, &quot;F&quot;))) dt ## name id age sex ## 1: a 4 18 M ## 2: b 1 45 F ## 3: c 5 54 F class(dt) ## [1] &quot;data.table&quot; &quot;data.frame&quot; Columns in a data table can be referenced directly, and new variables can be created using the := operator: # Selection with data frame vs. data table: df &lt;- as.data.frame(dt) # create a data frame for comparison df[df$sex == &quot;M&quot;, ] # select with data frame ## name id age sex ## 1 a 4 18 M dt[sex == &quot;M&quot;, ] # select with data table ## name id age sex ## 1: a 4 18 M # Variable assignment with data frame vs. data table: df$id_over_age &lt;- df$id / df$age # assign with data frame dt[, id_over_age := id / age] # assign with data table You can select multiple variables with a list: dt[, list(sex, age)] ## sex age ## 1: M 18 ## 2: F 45 ## 3: F 54 Multiple variables can be assigned simultaneously, where the LHS of the := operator is a character vector of new variable names, and the RHS is a list of operations: dt[, c(&quot;id_times_age&quot;, &quot;id_plus_age&quot;) := list(id * age, id + age)] dt ## name id age sex id_over_age id_times_age id_plus_age ## 1: a 4 18 M 0.22222222 72 22 ## 2: b 1 45 F 0.02222222 45 46 ## 3: c 5 54 F 0.09259259 270 59 Many operations in data analysis need to be done by group (e.g. calculating average unemployment by year). In such cases, data table introduces a third dimension to perform these operations. Specifically, the data table syntax is DT[i,j,by] with options to subset rows using i (which rows?), manipulate columns with j (what to do?), and group according to by (grouped by what?). Here is an example: # Produce table with average age by sex: dt[, mean(age), by = sex] ## sex V1 ## 1: M 18.0 ## 2: F 49.5 # Do the same but name the columns &quot;Gender&quot; and &quot;Age by Gender&quot;: dt[, list(`Age by Gender` = mean(age)), by = list(Gender = sex)] ## Gender Age by Gender ## 1: M 18.0 ## 2: F 49.5 # Assign a new variable with average age by sex named &quot;age_by_sex&quot;: dt[, age_by_sex := mean(age), by = sex] dt ## name id age sex id_over_age id_times_age id_plus_age age_by_sex ## 1: a 4 18 M 0.22222222 72 22 18.0 ## 2: b 1 45 F 0.02222222 45 46 49.5 ## 3: c 5 54 F 0.09259259 270 59 49.5 For additional information about data tables and their powerful features, check out the Intro to Data Table documentation and this cheat sheet for data.table functions. Furthermore, DataCamp provides several courses on data.table, such as: Data Manipulation with data.table in R Joining Data with data.table in R Time Series with data.table in R 3.2.8 Extensible Time Series (xts) xts (extensible time series) objects are specialized data structures designed for time series data. These are datasets where each observation corresponds to a specific timestamp. xts objects attach an index to the data, aligning each data point with its associated time. This functionality simplifies data manipulation and minimizes potential errors: Figure 3.3: Data with Index. Source: DataCamp. The index attached to an xts object is usually a Date or POSIXct vector, maintaining the data in chronological order from earliest to latest. If you wish to sort data (such as stock prices) by another variable (like trade volume), you’ll first need to convert the xts object back to a data frame, as xts objects preserve the time order. xts objects are built upon zoo objects (Zeileis’ Ordered Observations), another class of time-indexed data structures. xts objects enhance these base structures by providing additional features. Like tibble and data.table, xts is not included in base R. To use it, you need to install the xts package using install.packages(\"xts\"), then include library(\"xts\") at the start of your script. To create an xts object, use the xts() function which associates data with a time index (order.by = time_index): # Load R package library(&quot;xts&quot;) # Create a new xts object from a matrix: data &lt;- matrix(1:4, ncol = 2, nrow = 2, dimnames = list(NULL, c(&quot;a&quot;, &quot;b&quot;))) data ## a b ## [1,] 1 3 ## [2,] 2 4 time_index &lt;- as.Date(c(&quot;2020-06-01&quot;, &quot;2020-07-01&quot;)) time_index ## [1] &quot;2020-06-01&quot; &quot;2020-07-01&quot; dxts &lt;- xts(x = data, order.by = time_index) dxts ## a b ## 2020-06-01 1 3 ## 2020-07-01 2 4 class(dxts) ## [1] &quot;xts&quot; &quot;zoo&quot; tclass(dxts) ## [1] &quot;Date&quot; # Extract time index index(dxts) ## [1] &quot;2020-06-01&quot; &quot;2020-07-01&quot; # Extract data without time index coredata(dxts) ## a b ## [1,] 1 3 ## [2,] 2 4 To delve deeper into xts and zoo objects, consider reading the guides Manipulating Time Series Data in R with xts &amp; zoo and Time Series in R: Quick Reference. Additionally, DataCamp provides in-depth courses on these topics: Manipulating Time Series Data with xts and zoo in R Importing and Managing Financial Data in R If you’re working within the tidyverse environment, the R package tidyquant offers seamless integration with xts and zoo. Lastly, this handy cheat sheet provides a quick reference on xts and zoo functions. 3.3 Importing Data in R R is a software specialized for data analysis. To analyze data using R, the data must first be imported into the R environment. R offers robust functionality for importing data in a variety of formats. This section explores how to import data from CSV, TSV, and Excel files. Before we dive into specifics, let’s ensure RStudio can locate the data stored on your computer. 3.3.1 Working Directory The working directory in R is the folder where R starts when it’s looking for files to read or write. If you’re not sure where your current working directory is, you can use the getwd() (get working directory) command in R to find out: getwd() ## [1] &quot;/Users/julianludwig/Library/CloudStorage/Dropbox/Economics/teaching/4300_2023/module-01&quot; To change your working directory, use the setwd() (set working directory) function: setwd(&quot;your/folder/path&quot;) Be sure to replace \"your/folder/path\" with the actual path to your folder. When your files are stored in the same directory as your working directory, defined using the setwd() function, you can directly access these files by their names. For instance, read_csv(\"yieldcurve.csv\") will successfully read the file if “yieldcurve.csv” is in the working directory. If the file is located in a subfolder within the working directory, for example a folder named files, you would need to specify the folder in the file path when calling the file: read_csv(\"files/yieldcurve.csv\"). To find out the folder path for a specific file or folder on your computer, you can follow these steps: For Windows: Navigate to the folder using the File Explorer. Once you are in the folder, click on the address bar at the top of the File Explorer window. The address bar will now show the full path to the folder. This is the path you can set in R using the setwd() function. An example of a folder path on Windows might look like this: C:/Users/YourName/Documents/R. For MacOS: Open Finder and navigate to the folder. Once you are in the folder, Command-click (or right-click and hold, if you have a mouse) on the folder’s name at the top of the Finder window. A drop-down menu will appear showing the folder hierarchy. Hover over each folder in the hierarchy to show the full path, then copy this path. An example of a folder path on macOS might look like this: /Users/YourName/Documents/R. Remember, when setting the working directory in R, you need to use forward slashes (/) in the folder path, even on Windows where the convention is to use backslashes (\\). 3.3.2 CSV (Comma Separated Values) CSV (Comma Separated Values) is a common file format used to store tabular data. As the name suggests, the values in each row of a CSV file are separated by commas. Here’s an example of how data is stored in a CSV file: Male,8,100,3 Female,9,20,3 In this section, we’ll demonstrate how to import a CSV file using real-world Treasury yield curve rates data. Import Yield Curve Data in CSV Format To obtain the yield curve data, follow these steps: Visit the U.S. Treasury’s data center by clicking here. Click on “Data” in the menu bar, then select “Daily Treasury Par Yield Curve Rates.” On the data page, select “Download CSV” to obtain the yield curve data for the current year. To access all the yield curve data since 1990, choose “All” under the “Select Time Period” option, and click “Apply.” Please note that when selecting all periods, the “Download CSV” button may not be available. To manually save the data as a CSV file, you can copy the data by selecting it and using the Ctrl+C (or Cmd+C) command. Open an Excel file, and use the Ctrl+V (or Cmd+V) command to paste the data into the Excel file. Save the Excel file as a CSV file named ‘yieldcurve.csv’ in a location of your choice, ensuring that it is saved in a familiar folder for easy access. Next, install and load the readr package. Run install.packages(\"readr\") in the console and include the package at the top of your R script. You can then use the read_csv() or read_delim() function to import the yield curve data: # Load the package library(&quot;readr&quot;) # Import CSV file yc &lt;- read_csv(file = &quot;files/yieldcurve.csv&quot;, col_names = TRUE) ## Warning: One or more parsing issues, call `problems()` on your data frame for details, ## e.g.: ## dat &lt;- vroom(...) ## problems(dat) ## Rows: 8382 Columns: 14 ## ── Column specification ──────────────────────────────────────────────────────── ## Delimiter: &quot;,&quot; ## chr (6): Date, 1 Mo, 2 Mo, 4 Mo, 20 Yr, 30 Yr ## dbl (8): 3 Mo, 6 Mo, 1 Yr, 2 Yr, 3 Yr, 5 Yr, 7 Yr, 10 Yr ## ## ℹ Use `spec()` to retrieve the full column specification for this data. ## ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message. # Import CSV file using the read_delim() function yc &lt;- read_delim(file = &quot;files/yieldcurve.csv&quot;, col_names = TRUE, delim = &quot;,&quot;) ## Warning: One or more parsing issues, call `problems()` on your data frame for details, ## e.g.: ## dat &lt;- vroom(...) ## problems(dat) ## Rows: 8382 Columns: 14 ## ── Column specification ──────────────────────────────────────────────────────── ## Delimiter: &quot;,&quot; ## chr (6): Date, 1 Mo, 2 Mo, 4 Mo, 20 Yr, 30 Yr ## dbl (8): 3 Mo, 6 Mo, 1 Yr, 2 Yr, 3 Yr, 5 Yr, 7 Yr, 10 Yr ## ## ℹ Use `spec()` to retrieve the full column specification for this data. ## ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message. In the code snippets above, the read_csv() and read_delim() functions from the readr package are used to import a CSV file named “yieldcurve.csv”. The col_names = TRUE argument indicates that the first row of the CSV file contains column names. The delim = \",\" argument specifies that the columns are separated by commas, which is the standard delimiter for CSV (Comma Separated Values) files. Either one of the two functions can be used to read the CSV file and store the data in the variable yc for further analysis. To inspect the first few rows of the data, print the yc object in the console. For an overview of the entire dataset, use the View() function, which provides an interface similar to viewing the CSV file in Microsoft Excel: # Display the data yc ## # A tibble: 8,382 × 14 ## Date `1 Mo` `2 Mo` `3 Mo` `4 Mo` `6 Mo` `1 Yr` `2 Yr` `3 Yr` `5 Yr` `7 Yr` ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 01/02/… N/A N/A 7.83 N/A 7.89 7.81 7.87 7.9 7.87 7.98 ## 2 01/03/… N/A N/A 7.89 N/A 7.94 7.85 7.94 7.96 7.92 8.04 ## 3 01/04/… N/A N/A 7.84 N/A 7.9 7.82 7.92 7.93 7.91 8.02 ## 4 01/05/… N/A N/A 7.79 N/A 7.85 7.79 7.9 7.94 7.92 8.03 ## 5 01/08/… N/A N/A 7.79 N/A 7.88 7.81 7.9 7.95 7.92 8.05 ## 6 01/09/… N/A N/A 7.8 N/A 7.82 7.78 7.91 7.94 7.92 8.05 ## 7 01/10/… N/A N/A 7.75 N/A 7.78 7.77 7.91 7.95 7.92 8 ## 8 01/11/… N/A N/A 7.8 N/A 7.8 7.77 7.91 7.95 7.94 8.01 ## 9 01/12/… N/A N/A 7.74 N/A 7.81 7.76 7.93 7.98 7.99 8.07 ## 10 01/16/… N/A N/A 7.89 N/A 7.99 7.92 8.1 8.13 8.11 8.18 ## # ℹ 8,372 more rows ## # ℹ 3 more variables: `10 Yr` &lt;dbl&gt;, `20 Yr` &lt;chr&gt;, `30 Yr` &lt;chr&gt; # Display the data in a spreadsheet-like format View(yc) Both the read_csv() and read_delim() functions convert the CSV file into a tibble (tbl_df), a modern version of the R data frame discussed in Section 3.2.6. Remember, a data frame stores data in separate columns, each of which must be of the same data type. Use the class(yc) function to check the data type of the entire dataset, and sapply(yc, class) to check the data type of each column: # Check the data type of the entire dataset class(yc) ## [1] &quot;spec_tbl_df&quot; &quot;tbl_df&quot; &quot;tbl&quot; &quot;data.frame&quot; # Check the data type of each column sapply(yc, class) ## Date 1 Mo 2 Mo 3 Mo 4 Mo 6 Mo ## &quot;character&quot; &quot;character&quot; &quot;character&quot; &quot;numeric&quot; &quot;character&quot; &quot;numeric&quot; ## 1 Yr 2 Yr 3 Yr 5 Yr 7 Yr 10 Yr ## &quot;numeric&quot; &quot;numeric&quot; &quot;numeric&quot; &quot;numeric&quot; &quot;numeric&quot; &quot;numeric&quot; ## 20 Yr 30 Yr ## &quot;character&quot; &quot;character&quot; When importing data in R, it’s possible that R assigns incorrect data types to some columns. For example, the Date column is treated as a character column even though it contains dates, and the 30 Yr column is treated as a character column even though it contains interest rates. To address this issue, you can convert the first column to a date type and the remaining columns to numeric data types using the following three steps: Replace “N/A” with NA, which represents missing values in R. This step is necessary because R doesn’t recognize “N/A”, and if a column includes “N/A”, R will consider it as a character vector instead of a numeric vector. yc[yc == &quot;N/A&quot;] &lt;- NA Convert all yield columns to numeric data types: yc[, -1] &lt;- sapply(yc[, -1], as.numeric) The as.numeric() function converts a data object into a numeric type. In this case, it converts columns with character values like “3” and “4” into the numeric values 3 and 4. The sapply() function applies the as.numeric() function to each of the selected columns. This converts all the interest rates to numeric data types. Convert the date column to a date object, recognizing that the date format is Month/Day/Year or %m/%d/%Y: # Check the date format head(yc$Date) ## [1] &quot;01/02/1990&quot; &quot;01/03/1990&quot; &quot;01/04/1990&quot; &quot;01/05/1990&quot; &quot;01/08/1990&quot; ## [6] &quot;01/09/1990&quot; # Convert to date format yc$Date &lt;- as.Date(yc$Date, format = &quot;%m/%d/%Y&quot;) head(yc$Date) ## [1] &quot;1990-01-02&quot; &quot;1990-01-03&quot; &quot;1990-01-04&quot; &quot;1990-01-05&quot; &quot;1990-01-08&quot; ## [6] &quot;1990-01-09&quot; Hence, we have successfully imported the yield curve data and performed the necessary conversions to ensure that all columns are in their correct formats: yc ## # A tibble: 8,382 × 14 ## Date `1 Mo` `2 Mo` `3 Mo` `4 Mo` `6 Mo` `1 Yr` `2 Yr` `3 Yr` `5 Yr` ## &lt;date&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1990-01-02 NA NA 7.83 NA 7.89 7.81 7.87 7.9 7.87 ## 2 1990-01-03 NA NA 7.89 NA 7.94 7.85 7.94 7.96 7.92 ## 3 1990-01-04 NA NA 7.84 NA 7.9 7.82 7.92 7.93 7.91 ## 4 1990-01-05 NA NA 7.79 NA 7.85 7.79 7.9 7.94 7.92 ## 5 1990-01-08 NA NA 7.79 NA 7.88 7.81 7.9 7.95 7.92 ## 6 1990-01-09 NA NA 7.8 NA 7.82 7.78 7.91 7.94 7.92 ## 7 1990-01-10 NA NA 7.75 NA 7.78 7.77 7.91 7.95 7.92 ## 8 1990-01-11 NA NA 7.8 NA 7.8 7.77 7.91 7.95 7.94 ## 9 1990-01-12 NA NA 7.74 NA 7.81 7.76 7.93 7.98 7.99 ## 10 1990-01-16 NA NA 7.89 NA 7.99 7.92 8.1 8.13 8.11 ## # ℹ 8,372 more rows ## # ℹ 4 more variables: `7 Yr` &lt;dbl&gt;, `10 Yr` &lt;dbl&gt;, `20 Yr` &lt;dbl&gt;, `30 Yr` &lt;dbl&gt; Here, &lt;dbl&gt; stands for double, which is the R data type for decimal numbers, also known as numeric type. Converting the yield columns to dbl ensures that the values are treated as numeric and can be used for calculations, analysis, and visualization. Plot Historical Trends in Treasury Yields Let’s use the plot() function to visualize the imported yield curve data. In this case, we will plot the 3-month Treasury rate over time, using the Date column as the x-axis and the 3 Mo column as the y-axis: # Plot the 3-month Treasury rate over time plot(x = yc$Date, y = yc$`3 Mo`, type = &quot;l&quot;, xlab = &quot;Date&quot;, ylab = &quot;%&quot;, main = &quot;3-Month Treasury Rate&quot;) In the code snippet above, plot() is the R function used to create the plot. It takes several arguments to customize the appearance and behavior of the plot: x represents the data to be plotted on the x-axis. In this case, it corresponds to the Date column from the yield curve data. y represents the data to be plotted on the y-axis. Here, it corresponds to the 3 Mo column, which represents the 3-month Treasury rate. type = \"l\" specifies the type of plot to create. In this case, we use \"l\" to create a line plot. xlab = \"Date\" sets the label for the x-axis to “Date”. ylab = \"%\" sets the label for the y-axis to “%”. main = \"3-Month Treasury Rate\" sets the title of the plot to “3-Month Treasury Rate”. Figure 3.4: 3-Month Treasury Rate The resulting plot, shown in Figure 3.4, displays the historical evolution of the 3-month Treasury rate since 1990. It allows us to observe how interest rates have changed over time, with low rates often observed during recessions and high rates during boom periods. Recessions are typically characterized by reduced borrowing and investment activities, leading to decreased demand for credit and lower interest rates. Conversely, boom periods are associated with strong economic growth and increased credit demand, which can drive interest rates upward. Furthermore, inflation plays a significant role in influencing interest rates through the Fisher effect. When inflation is high, lenders and investors are concerned about the diminishing value of money over time. To compensate for the erosion of purchasing power, lenders typically demand higher interest rates on loans. These higher interest rates reflect the expectation of future inflation and act as a safeguard against the declining value of the money lent. Conversely, when inflation is low, lenders may offer lower interest rates due to reduced concerns about the erosion of purchasing power. Plot Yield Curve Next, let’s plot the yield curve. The yield curve is a graphical representation of the relationship between the interest rates (yields) and the time to maturity of a bond. It provides insights into market expectations regarding future interest rates and economic conditions. To plot the yield curve, we will select the most recently available data from the dataset, which corresponds to the last row. We will extract the interest rates as a numeric vector and the column names (representing the time to maturity) as labels for the x-axis: # Extract the interest rates of the last row yc_most_recent_data &lt;- as.numeric(last(yc[, -1])) yc_most_recent_data ## [1] 5.24 5.39 5.43 5.50 5.47 5.40 4.87 4.49 4.13 3.97 3.81 4.06 3.85 # Extract the column names of the last row yc_most_recent_labels &lt;- colnames(last(yc[, -1])) yc_most_recent_labels ## [1] &quot;1 Mo&quot; &quot;2 Mo&quot; &quot;3 Mo&quot; &quot;4 Mo&quot; &quot;6 Mo&quot; &quot;1 Yr&quot; &quot;2 Yr&quot; &quot;3 Yr&quot; &quot;5 Yr&quot; ## [10] &quot;7 Yr&quot; &quot;10 Yr&quot; &quot;20 Yr&quot; &quot;30 Yr&quot; # Plot the yield curve plot(x = yc_most_recent_data, xaxt = &#39;n&#39;, type = &quot;o&quot;, pch = 19, xlab = &quot;Time to Maturity&quot;, ylab = &quot;Treasury Rate in %&quot;, main = paste(&quot;Yield Curve on&quot;, format(last(yc$Date), format = &#39;%B %d, %Y&#39;))) axis(side = 1, at = seq(1, length(yc_most_recent_labels), 1), labels = yc_most_recent_labels) In the code snippet above, plot() is the R function used to create the yield curve plot. Here are the key inputs and arguments used in the function: x = yc_most_recent_data represents the interest rates of the most recent yield curve data, which will be plotted on the x-axis. xaxt = 'n' specifies that no x-axis tick labels should be displayed initially. This is useful because we will customize the x-axis tick labels separately using the axis() function. type = \"o\" specifies that the plot should be created as a line plot with points. This will display the yield curve as a connected line with markers at each data point. pch = 19 sets the plot symbol to a solid circle, which will be used as markers for the data points on the yield curve. xlab = \"Time to Maturity\" sets the label for the x-axis to “Time to Maturity”, indicating the variable represented on the x-axis. ylab = \"Treasury Rate in %\" sets the label for the y-axis to “Treasury Rate in %”, indicating the variable represented on the y-axis. main = paste(\"Yield Curve on\", format(last(yc$Date), format = '%B %d, %Y')) sets the title of the plot to “Yield Curve on” followed by the date of the most recent yield curve data. Additionally, the axis() function is used to customize the x-axis tick labels. It sets the tick locations using at = seq(1, length(yc_most_recent_labels), 1) to evenly space the ticks along the x-axis. The labels = yc_most_recent_labels argument assigns the column names of the last row (representing maturities) as the tick labels on the x-axis. Figure 3.5: Yield Curve on June 30, 2023 The resulting plot, shown in Figure 3.5, depicts the yield curve based on the most recent available data, allowing us to visualize the relationship between interest rates and the time to maturity. The x-axis represents the different maturities of the bonds, while the y-axis represents the corresponding treasury rates. Analyzing the shape of the yield curve can provide insights into market expectations and can be useful for assessing economic conditions and making investment decisions. The yield curve can take different shapes, such as upward-sloping (normal), downward-sloping (inverted), or flat, each indicating different market conditions and expectations for future interest rates. An upward-sloping yield curve, where longer-term interest rates are higher than shorter-term rates, is often seen during periods of economic expansion. This shape suggests that investors expect higher interest rates in the future as the economy grows and inflationary pressures increase. It reflects an optimistic outlook for economic conditions, as borrowing and lending activity are expected to be robust. In contrast, a downward-sloping or inverted yield curve, where shorter-term interest rates are higher than longer-term rates, is often considered a predictor of economic slowdown or recession. This shape suggests that investors anticipate lower interest rates in the future as economic growth slows and inflationary pressures decrease. It reflects a more cautious outlook for the economy, as investors seek the safety of longer-term bonds amid expectations of lower returns and potential economic downturn. Inflation expectations also influence the shape of the yield curve. When there are high inflation expectations for the long term, the yield curve tends to slope upwards. This occurs because lenders demand higher interest rates for longer maturities to compensate for anticipated inflation. However, when there is currently high inflation but expectations are that the central bank will successfully control inflation in the long term, the yield curve may slope downwards. In this case, long-term interest rates are lower than short-term rates, as average inflation over the long term is expected to be lower than in the short term. 3.3.3 TSV (Tab Separated Values) TSV (Tab Separated Values) is a common file format used to store tabular data. As the name suggests, the values in each row of a TSV file are separated by tabs. Here’s an example of how data is stored in a TSV file: Male    8    100    3 Female    9    20    3 In this section, we’ll demonstrate how to import a TSV file using real-world consumer survey data collected by the University of Michigan. Import Michigan Consumer Survey Data in TSV Format To obtain the Michigan consumer survey data, follow these steps: Visit the website of University of Michigan’s surveys of consumers by clicking here. Click on “DATA” in the menu bar, then select “Time Series.” On the data page, under Table, select “All: All Tables (Tab-delimited or CSV only)” to obtain the consumer survey data on all topics. To access all the consumer survey data since 1978, type “1978” under the “Oldest Year” option. Click on “Tab-Deliminated (Excel)” under the “format” option. Save the TSV file in a location of your choice, ensuring that it is saved in a familiar folder for easy access. The dataset contains 360 variables with coded column names such as ics_inc31 or pago_dk_all. To understand the meaning of these columns, you can visit the same website here and click on SURVEY INFORMATION. From there, select the Time-Series Variable Codebook which is a PDF document that provides detailed explanations for all the column names. By referring to this codebook, you can gain a better understanding of the variables and their corresponding meanings in the dataset. Next, to import the consumer survey data, you need to install and load the readr package if you haven’t done so already. Once the package is loaded, you can use either the read_tsv() or read_delim() function to read the TSV (Tab-Separated Values) file. # Load the package library(&quot;readr&quot;) # Import TSV file cs &lt;- read_tsv(file = &quot;files/sca-tableall-on-2023-Jul-01.tsv&quot;, skip = 1) ## New names: ## Rows: 545 Columns: 360 ## ── Column specification ## ──────────────────────────────────────────────────────── Delimiter: &quot;\\t&quot; dbl ## (359): Month, yyyy, ics_all, ics_inc31, ics_inc32, ics_inc33, ics_a1834,... lgl ## (1): ...360 ## ℹ Use `spec()` to retrieve the full column specification for this data. ℹ ## Specify the column types or set `show_col_types = FALSE` to quiet this message. ## • `` -&gt; `...360` # Import TSV file using the read_delim() function cs &lt;- read_delim(file = &quot;files/sca-tableall-on-2023-Jul-01.tsv&quot;, skip = 1, col_names = TRUE, delim = &quot;\\t&quot;) ## New names: ## Rows: 545 Columns: 360 ## ── Column specification ## ──────────────────────────────────────────────────────── Delimiter: &quot;\\t&quot; dbl ## (359): Month, yyyy, ics_all, ics_inc31, ics_inc32, ics_inc33, ics_a1834,... lgl ## (1): ...360 ## ℹ Use `spec()` to retrieve the full column specification for this data. ℹ ## Specify the column types or set `show_col_types = FALSE` to quiet this message. ## • `` -&gt; `...360` In the provided code snippets, the file input specifies the file path or URL of the TSV file to be imported. The skip input is used to specify the number of rows to skip at the beginning of the file. In this case, skip = 1 indicates that the first line of the TSV file, which contains the title “All Tables”, should be skipped. The col_names input is set to TRUE to indicate that the second line of the TSV file (after skipping 1 row) contains the column names. Lastly, the delim input is set to \"\\t\" to specify that the columns in the TSV file are separated by tabs, which is the standard delimiter for TSV (Tab Separated Values) files. Note that if the file is neither CSV nor TSV, but rather has an exotic format where columns are separated by a different character that is neither a comma nor a tab, such as “/”, you can use the read_delim() function with the delim = \"/\" argument to specify the custom delimiter. To inspect the first few rows of the data, print the cs object in the console. For an overview of the entire dataset, execute View(cs). # Display the data cs ## # A tibble: 545 × 360 ## Month yyyy ics_all ics_inc31 ics_inc32 ics_inc33 ics_a1834 ics_a3554 ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1 1978 83.7 NA NA NA 93.7 86.7 ## 2 2 1978 84.3 NA NA NA 99.7 82.3 ## 3 3 1978 78.8 NA NA NA 91.7 76.8 ## 4 4 1978 81.6 NA NA NA 91.8 79.7 ## 5 5 1978 82.9 NA NA NA 95.1 78.9 ## 6 6 1978 80 NA NA NA 91.7 75.7 ## 7 7 1978 82.4 NA NA NA 92.2 78.4 ## 8 8 1978 78.4 NA NA NA 87.8 77.2 ## 9 9 1978 80.4 NA NA NA 86.6 83.9 ## 10 10 1978 79.3 NA NA NA 90.6 76.7 ## # ℹ 535 more rows ## # ℹ 352 more variables: ics_a5597 &lt;dbl&gt;, ics_ne &lt;dbl&gt;, ics_nc &lt;dbl&gt;, ## # ics_s &lt;dbl&gt;, ics_w &lt;dbl&gt;, icc_all &lt;dbl&gt;, ice_all &lt;dbl&gt;, pago_f_all &lt;dbl&gt;, ## # pago_s_all &lt;dbl&gt;, pago_u_all &lt;dbl&gt;, pago_dk_all &lt;dbl&gt;, pago_r_all &lt;dbl&gt;, ## # pagorn_hy_all &lt;dbl&gt;, pagorn_ha_all &lt;dbl&gt;, pagorn_ld_all &lt;dbl&gt;, ## # pagorn_ly_all &lt;dbl&gt;, pagorn_hp_all &lt;dbl&gt;, pagorn_la_all &lt;dbl&gt;, ## # pagorn_hd_all &lt;dbl&gt;, pagorn_ny_all &lt;dbl&gt;, pagorn_nad_all &lt;dbl&gt;, … Use sapply(cs, class) to check the data type of each column, to make sure all columns are indeed numeric: # Check the data type of each column table(sapply(cs, class)) ## ## logical numeric ## 1 359 Here, since there are 360 columns, the summary() function is applied, which reveals that there are 359 numerical columns, and 1 logical column, which makes sense. Instead of a date column, the consumer survey has a year (yyyy) and a month (Month) column. To create a date column from the year and month columns, combine them with the paste() function to create a date format of the form Year-Month-Day or %Y-%m-%d: # Create date column cs$Date &lt;- as.Date(paste(cs$yyyy, cs$Month, &quot;01&quot;, sep = &quot;-&quot;)) head(cs$Date) ## [1] &quot;1978-01-01&quot; &quot;1978-02-01&quot; &quot;1978-03-01&quot; &quot;1978-04-01&quot; &quot;1978-05-01&quot; ## [6] &quot;1978-06-01&quot; Plot Consumer Indices The Michigan Consumer Survey consists of a wide range of survey responses from a sample of households collected every month. These survey responses are gathered to produce indices about how consumers feel each period. The University of Michigan produces three main indices: the Index of Consumer Confidence (ICC), the Index of Current Economic Conditions (ICE), and the Index of Consumer Sentiment (ICS). These indices are designed to measure different aspects of consumer attitudes and perceptions regarding the economy. Index of Consumer Confidence (ICC): The ICC reflects consumers’ expectations about future economic conditions and their overall optimism or pessimism. It is based on consumers’ assessments of their future financial prospects, job availability, and economic outlook. A higher ICC value indicates greater consumer confidence and positive expectations for the economy. Index of Current Economic Conditions (ICE): The ICE assesses consumers’ perceptions of the current economic environment. It reflects their evaluations of their personal financial situation, job security, and their perception of whether it is a good time to make major purchases. The ICE provides insights into the current economic conditions as perceived by consumers. Index of Consumer Sentiment (ICS): The ICS combines both the ICC and ICE to provide an overall measure of consumer sentiment. It takes into account consumers’ expectations for the future as well as their assessment of the present economic conditions. The ICS is often used as an indicator of consumer behavior and their likelihood of making purchases and engaging in economic activities. These indices are calculated based on survey responses from a sample of households, and they serve as important indicators of consumer sentiment and economic trends. They are widely followed by economists, policymakers, and financial markets as they provide valuable insights into consumers’ attitudes and perceptions, which can impact their spending behavior and overall economic activity. Let’s use the plot() function to visualize the imported Michigan consumer survey data. In this case, we will plot the three key indices: ICC, ICE, and ICS over time, using the Date column as the x-axis and the three indices as the y-axis: # Plot ICC, ICE, and ICS over time plot(x = cs$Date, y = cs$icc_all, type = &quot;l&quot;, col = 5, lwd = 3, ylim = c(40, 140), xlab = &quot;Date&quot;, ylab = &quot;Index&quot;, main = &quot;Key Indices of the Michigan Consumer Survey&quot;) lines(x = cs$Date, y = cs$ice_all, col = 2, lwd = 2) lines(x = cs$Date, y = cs$ics_all, col = 1, lwd = 1.5) legend(x = &quot;topleft&quot;, legend = c(&quot;ICC&quot;, &quot;ICE&quot;, &quot;ICS&quot;), col = c(5, 2, 1), lwd = c(3, 2, 1.5), horiz = TRUE) In the code snippet provided, the appearance and behavior of the plot are customized using several functions and arguments: x: This argument specifies the data to be used for the x-axis of the plot. In this case, it is cs$Date, indicating the “Date” column of the Michigan consumer survey data. y: This argument specifies the data to be used for the y-axis of the plot. In this case, it is cs$icc_all, cs$ice_all, and cs$ics_all, representing the ICC, ICE, and ICS indices from the Michigan consumer survey data. type: This argument determines the type of plot to be created. In this case, it is set to \"l\", which stands for “line plot”. This will create a line plot of the data points. col: This argument specifies the color of the lines in the plot. In the code snippet, different colors are used for each index: 5 for ICC, 2 for ICE, and 1 for ICS. lwd: This argument controls the line width of the plot. It is set to 3 for ICC, 2 for ICE, and 1.5 for ICS, indicating different line widths for each index. ylim: This argument sets the limits of the y-axis. In this case, it is set to c(40, 140), which defines the range of the y-axis from 40 to 140. xlab: This argument specifies the label for the x-axis of the plot. In the code snippet, it is set to \"Date\". ylab: This argument specifies the label for the y-axis of the plot. In the code snippet, it is set to \"Index\". main: This argument specifies the main title of the plot. In the code snippet, it is set to \"Key Indices of the Michigan Consumer Survey\". lines: This function is used to add additional lines to the plot. legend: This function adds a legend to the plot. It is used to create a legend in the top-left corner (x = \"topleft\") with labels corresponding to each index (\"ICC\", \"ICE\", \"ICS\") and their respective line colors and widths. Figure 3.6: Key Indices of the Michigan Consumer Survey The resulting plot, shown in Figure 3.6, displays the historical evolution of the three Michigan consumer survey indices: ICC, ICE, and ICS. These indices are considered leading indicators because they provide early signals about changes in consumer sentiment and economic conditions. They often reflect consumers’ expectations and attitudes before these changes are fully manifested in traditional economic indicators, such as unemployment rates or GDP growth. Consumer sentiment plays a crucial role in shaping consumer behavior, including spending patterns, saving habits, and investment decisions. When consumer confidence is high, individuals are more likely to spend and invest, stimulating economic growth. Conversely, low consumer confidence can lead to reduced spending and investment, potentially dampening economic activity. Hence, these indices can serve as an early warning system for potential shifts in economic activity. By incorporating the consumer survey indices alongside traditional economic indicators, policymakers and analysts can gain a more comprehensive understanding of the economic landscape. While traditional indicators like unemployment rates provide objective measures of economic conditions, the consumer survey indices offer a subjective perspective, reflecting consumers’ beliefs, expectations, and intentions. This subjective insight can provide additional context and help anticipate changes in consumer behavior and overall economic activity. Therefore, by monitoring both traditional economic indicators and the Michigan consumer survey indices, policymakers and analysts can obtain a more holistic view of the economy, enabling them to make more informed decisions and implement timely interventions to support economic stability and growth. 3.3.4 Excel File CSV (Comma Separated Values) is a common file format used to store tabular data. As the name suggests, the values in each row of a CSV file are separated by commas. Here’s an example of how data is stored in a CSV file: Male,8,100,3 Female,9,20,3 In this section, we’ll demonstrate how to import a CSV file using real-world Treasury yield curve rates data. Import Yield Curve Data in CSV Format To obtain the yield curve data, follow these steps: Visit the U.S. Treasury’s data center by clicking here. Click on “Data” in the menu bar, then select “Daily Treasury Par Yield Curve Rates.” On the data page, select “Download CSV” to obtain the yield curve data for the current year. To access all the yield curve data since 1990, choose “All” under the “Select Time Period” option, and click “Apply.” Please note that when selecting all periods, the “Download CSV” button may not be available. To manually save the data as a CSV file, you can copy the data by selecting it and using the Ctrl+C (or Cmd+C) command. Open an Excel file, and use the Ctrl+V (or Cmd+V) command to paste the data into the Excel file. Save the Excel file as a CSV file named ‘yieldcurve.csv’ in a location of your choice, ensuring that it is saved in a familiar folder for easy access. Next, install and load the readr package. Run install.packages(\"readr\") in the console and include the package at the top of your R script. You can then use the read_csv() or read_delim() function to import the yield curve data: # Load the package library(&quot;readr&quot;) # Import CSV file yc &lt;- read_csv(file = &quot;files/yieldcurve.csv&quot;, col_names = TRUE) ## Warning: One or more parsing issues, call `problems()` on your data frame for details, ## e.g.: ## dat &lt;- vroom(...) ## problems(dat) ## Rows: 8382 Columns: 14 ## ── Column specification ──────────────────────────────────────────────────────── ## Delimiter: &quot;,&quot; ## chr (6): Date, 1 Mo, 2 Mo, 4 Mo, 20 Yr, 30 Yr ## dbl (8): 3 Mo, 6 Mo, 1 Yr, 2 Yr, 3 Yr, 5 Yr, 7 Yr, 10 Yr ## ## ℹ Use `spec()` to retrieve the full column specification for this data. ## ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message. # Import CSV file using the read_delim() function yc &lt;- read_delim(file = &quot;files/yieldcurve.csv&quot;, col_names = TRUE, delim = &quot;,&quot;) ## Warning: One or more parsing issues, call `problems()` on your data frame for details, ## e.g.: ## dat &lt;- vroom(...) ## problems(dat) ## Rows: 8382 Columns: 14 ## ── Column specification ──────────────────────────────────────────────────────── ## Delimiter: &quot;,&quot; ## chr (6): Date, 1 Mo, 2 Mo, 4 Mo, 20 Yr, 30 Yr ## dbl (8): 3 Mo, 6 Mo, 1 Yr, 2 Yr, 3 Yr, 5 Yr, 7 Yr, 10 Yr ## ## ℹ Use `spec()` to retrieve the full column specification for this data. ## ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message. In the code snippets above, the read_csv() and read_delim() functions from the readr package are used to import a CSV file named “yieldcurve.csv”. The col_names = TRUE argument indicates that the first row of the CSV file contains column names. The delim = \",\" argument specifies that the columns are separated by commas, which is the standard delimiter for CSV (Comma Separated Values) files. Either one of the two functions can be used to read the CSV file and store the data in the variable yc for further analysis. To import Excel files, we use the readxl package. To import an Excel file, execute install.packages(\"readxl\") in the console, and then load the package at the start of your R script. # Load the package library(&quot;readxl&quot;) # Print names of all worksheets # Replace &#39;path&#39; with your Excel file path # excel_sheets(path=&quot;car.xlsx&quot;) # Import the sheet you want # Replace &#39;path&#39; and &#39;sheet&#39; with your Excel file path and sheet name # car &lt;- read_excel(path=&quot;car.xlsx&quot;,sheet=&quot;Statistics_A&quot;,col_names=TRUE) # Import all sheets # Replace &#39;path&#39; with your Excel file path # car_list &lt;- lapply(excel_sheets(path=&quot;car.xlsx&quot;),read_excel, path=&quot;car.xlsx&quot;,col_names=TRUE) 3.3.5 Saving Data Once the data has been imported and possibly manipulated, it can be saved in various formats. # Save data in different formats save(yc, file=&quot;yieldcurve.RData&quot;) write_csv(x=yc, path=&quot;yieldcurve.csv&quot;, na=&quot;NA&quot;) ## Warning: The `path` argument of `write_csv()` is deprecated as of readr 1.4.0. ## ℹ Please use the `file` argument instead. ## This warning is displayed once every 8 hours. ## Call `lifecycle::last_lifecycle_warnings()` to see where this warning was ## generated. # Other formats can be used by replacing &#39;yieldcurve&#39; with your data and &#39;path&#39; with your desired file name and format For more information on importing data in R, consider taking DataCamp’s Introduction to Importing Data in R course. "],["datacamp.html", "Chapter 4 DataCamp", " Chapter 4 DataCamp To learn more about R Markdown, consider reading R Markdown: The Definitive Guide. Create an account on www.datacamp.com with the free student license you receive by email Take Introduction to R for Finance on DataCamp Then take additional courses and explore some of the exciting things you can do with R (and Python) For Economics and Business students I recommend The entire skill track Finance Fundamentals in R The entire skill track Applied Finance in R The entire skill track Importing &amp; Cleaning Data with R The entire skill track Data Visualization with R The entire skill track Interactive Data Visualization in R The entire career track Quantitative Analyst with R Reporting with R Markdown to learn how to write reports Spreadsheet Fundamentals to learn Excel "],["assignment.html", "Chapter 5 Assignment", " Chapter 5 Assignment Work through all chapters of Module 1: Introduction to R. DataCamp courses: A B Create "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
